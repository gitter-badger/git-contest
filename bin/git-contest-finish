#!/usr/bin/env ruby

#
# git-contest-finish
# https://github.com/sh19910711/git-contest
#
# Copyright (c) 2013-2014 Hiroyuki Sano <sh19910711 at gmail.com>
# Licensed under the MIT-License.
#

$:.unshift File.expand_path('../../lib', __FILE__)
require 'git/contest/common'
require 'trollop'

def use_current_branch
  current_branch = Git.current_branch
  if current_branch.start_with? $PREFIX
    $BRANCH = current_branch.strip
    $NAME = $BRANCH[$PREFIX.length+1..-1]
  else
    puts "The current HEAD is no feature branch."
    puts "Please spefcify a <name> argument."
    abort ''
  end
end

def expand_contest_branch
  if ARGV.length == 0
    use_current_branch
  else
    $NAME = ARGV[0]
    $BRANCH = "#{$PREFIX}/#{$NAME}"
    Git.require_branch $BRANCH
  end
end

def helper_finish_cleanup
  Git.require_branch $BRANCH
  Git.require_clean_working_tree

  if $options[:fetch]
    Git.do "push \"#{$ORIGIN}\" \":refs/heads/#{$BRANCH}\""
  end

  if ! $options[:keep]
    if $options[:force_delete]
      Git.do "branch -D #{$BRANCH}"
    else
      Git.do "branch -d #{$BRANCH}"
    end
  end

  puts ""
  puts "Summary of actions:"
  puts "- The contest branch \"#{$BRANCH}\" was merged into \"#{$MASTER}\""
  puts "- Contest branch \"#{$BRANCH}\" has been removed"
  puts "- You are now on branch \"#{$MASTER}\""
  puts ""
end

init

sub_commands = %w()
$options = Trollop::options do
  version "git-contest #{Git::Contest::VERSION} (c) 2013-2014 Hiroyuki Sano"
  opt(
    :no_edit,
    "Use default commit message.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  opt(
    :keep,
    "Keep contest branch after merge.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  opt(
    :rebase,
    "Use rebase instead of merge.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  opt(
    :force_delete,
    "Force delete contest branch after finish.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  opt(
    :squash,
    "Use squash during merge.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  opt(
    :fetch,
    "Fetch from origin before finish.",
    :type => :flag,
    :default => false,
    :required => false,
  )
  stop_on sub_commands
end

expand_contest_branch()
Git.require_branch $BRANCH

Git.require_clean_working_tree

if Git.remote_branches().include?("#{$ORIGIN}/#{$BRANCH}")
  if $options[:fetch]
    Git.do "fetch -q \"#{$ORIGIN}\" \"#{$BRANCH}\""
    Git.do "fetch -q \"#{$ORIGIN}\" \"#{$MASTER}\""
  end
end

if Git.remote_branches().include?("#{$ORIGIN}/#{$BRANCH}")
  Git.require_branches_equal $BRANCH, "#{$ORIGIN}/#{$BRANCH}"
end

if Git.remote_branches().include?("#{$ORIGIN}/#{$MASTER}")
  Git.require_branches_equal $MASTER, "#{$ORIGIN}/#{$MASTER}"
end

merge_options = ""
if $options[:no_edit]
  merge_options += " --no-edit"
end

if $options[:rebase]
  ret = Git.do "contest rebase \"#{$NAME}\" \"#{$MASTER}\""
  exitcode = $?.to_i
  if ! $?
    puts "Finish was aborted due to conflicts during rebase."
    exit 1
  end
end

Git.do "checkout #{$MASTER}"
if Git.do("rev-list -n2 \"#{$MASTER}..#{$BRANCH}\"").lines.to_a.length == 1
  Git.do "merge --ff \"#{$BRANCH}\" #{merge_options}"
else
  if $options[:squash]
    Git.do "merge --squash \"#{$BRANCH}\" #{merge_options}"
    if $options[:no_edit]
      Git.do "commit -m 'Squashed commit'"
    else
      Git.do "commit"
    end
    Git.do "merge \"#{$BRANCH}\" #{merge_options}"
  else
    Git.do "merge --no-ff \"#{$BRANCH}\" #{merge_options}"
  end
end

helper_finish_cleanup

